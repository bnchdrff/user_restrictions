<?php
// $Id$

/**
 * @file
 * Enables restrictions on user names and e-mail addresses.
 */

class UserRestrictions {
  /**
   * The user restriction ID.
   */
  public $urid = 0;

  /**
   * The user restriction mask.
   */
  public $mask = '';

  /**
   * The user restriction type.
   */
  public $type = '';

  /**
   * The user restriction sub-type.
   */
  public $subtype = '';

  /**
   * The user restriction status.
   */
  public $status = 0;

  /**
   * When the user restriction expires, or 0 if it doesn't expire.
   */
  public $expire = 0;

  /**
   * Checks the user input against user restrictions.
   *
   * This was handled by drupal_is_denied() in version of Drupal prior to 7.x.
   *
   * @param $form_state
   *   The array passed to form API functions.
   * @param $form_type
   *   The form for which the function is invoked.
   *
   * @return
   *   A message error if there are restrictions agains the entered value, or
   *   an empty string if there are no restrictions that do not allow to use
   *   the entered value.
   */
  public static function check($form_state, $form_type = 'login') {
    $fields = module_invoke_all('user_restrictions_info', 'fields', $form_state, $form_type);
    foreach ($fields as $type => $mask) {
      $args = array(
        ':type' => $type,
        ':subtype' => $form_type,
        ':mask' => $mask,
        ':now' => REQUEST_TIME,
      );
      $context = array(
        'type' => $type,
        'mask' => $mask,
        'time' => REQUEST_TIME,
        'form_state' => $form_state,
        'form_type' => $form_type,
      );
      $sql = 'SELECT 1 FROM {user_restrictions} WHERE type = :type AND (subtype = :subtype OR subtype = '') AND LOWER(:mask) LIKE LOWER(mask) AND status = :status AND (expire > :now OR expire = 0)';

      // We deny access if the only matching records in the {user_restrictions}
      // table have status 0 (deny). If any have status 1 (allow), or if there are
      // no matching records, we allow access.
      $denied = (
        db_query_range($sql, 0, 1, $args + array(':status' => 0))->fetchField() &&
        !db_query_range($sql, 0, 1, $args + array(':status' => 1))->fetchField()
      );
      $error = array(
        'field' => &$field,
        'message' => &$message,
      );

      // Allow third-party modules to alter the user restriction rule.
      drupal_alter('user_restrictions', $denied, $error, $context);

      if ($denied) {
        break;
      }
    }

    return $error;
  }

  public static function exists($array) {
    $query = db_select('user_restrictions', 'ur')
      ->fields('ur', array('urid'))
      ->where('type = :type AND LOWER(:mask) = LOWER(mask)', $array);

    if (isset($array['subtype'])) {
      $query->condition('subtype', $array['subtype']);
    }

    return (boolean) $query->execute()->fetchField();
  }

  public function delete() {
    db_delete('user_restrictions')
      ->condition('urid', $this->urid)
      ->execute();
  }

  public static function getInstance($id = '') {
    if ($id) {
      $instance = db_query('SELECT * FROM {user_restrictions} WHERE urid = :urid', array(':urid' => $id), array('fetch' => 'UserRestrictions'))
        ->fetchObject();
    }
    else {
      $instance = new UserRestrictions();
    }

    return empty($instance) ? FALSE : $instance;
  }

  public static function getRestrictionTable($header) {
    $access_types = self::getTypeOptions();
    $rules = db_select('user_restrictions', 'ur')
      ->fields('ur', array('urid', 'type', 'status', 'mask'))
      ->condition('expire', 0)
      ->extend('PagerDefault')
      ->limit(50)
      ->extend('TableSort')
      ->orderByHeader($header)
      ->execute();

    foreach ($rules as $rule) {
      $rows[$rule->urid]['status'] = $rule->status ? t('allow') : t('deny');
      $rows[$rule->urid]['type'] = $access_types[$rule->type];
      $rows[$rule->urid]['mask'] = check_plain($rule->mask);
      $rows[$rule->urid]['operations'] = array(
        'data' => array(
          '#theme' => 'links__user_restrictions_ui_rule_operations',
          '#links' => array(
            'edit' => array(
              'title' => t('edit'),
              'href' => 'admin/config/people/user-restrictions/' . $rule->urid . '/edit',
              'query' => $destination,
              '#attributes' => array('class' => array('links', 'inline')),
            ),
            'delete' => array(
              'title' => t('delete'),
              'href' => 'admin/config/people/user-restrictions/' . $rule->urid . '/delete',
              'query' => $destination,
              '#attributes' => array('class' => array('links', 'inline')),
            ),
          ),
        ),
      );
    }
  }

  public static function getStatusOptions() {
    $info = module_invoke_all('user_restrictions_info', 'status options');
    drupal_alter('user_restrictions_info', $info, array('status options'));

    return $info;
  }

  public static function getTypeOptions() {
    $info = module_invoke_all('user_restrictions_info', 'type options');
    drupal_alter('user_restrictions_info', $info, array('type options'));

    return $info;
  }

  public function save() {
    $primary_keys = array();
    $record = new stdClass();

    if (!empty($this->urid)) {
      $primary_keys[] = 'urid';
    }

    return drupal_write_record('user_restrictions', clone $this, $primary_keys);
  }
}

/**
 * Implements hook_cron().
 */
function user_restrictions_cron() {
  db_delete('user_restrictions')
    ->condition('expire', REQUEST_TIME, '<=')
    ->execute();
}

/**
 * Implements hook_form_FORM_ID_alter() for user_login().
 */
function user_restrictions_form_user_login_alter(&$form, &$form_state) {
  $form['#validate'][] = 'user_restrictions_login_form_validate';
}

/**
 * Implements hook_form_FORM_ID_alter() for user_login_block().
 */
function user_restrictions_form_user_login_block_alter(&$form, &$form_state) {
  $form['#validate'][] = 'user_restrictions_login_form_validate';
}

/**
 * Implements hook_form_FORM_ID_alter() for user_profile_form().
 */
function user_restrictions_form_user_profile_form_alter(&$form, &$form_state) {
  $form['#validate'][] = 'user_restrictions_user_profile_form_validate';
}

/**
 * Implements hook_form_FORM_ID_alter() for user_register_form().
 */
function user_restrictions_form_user_register_form_alter(&$form, &$form_state) {
  $form['#validate'][] = 'user_restrictions_user_register_form_validate';
}

/**
 * Implements hook_help().
 */
function user_restrictions_help($path, $arg) {
  if ($path == 'admin/help#user_restrictions') {
    return '<p>' . t("The user restrictions module allows you to specify rules for allowable usernames, or e-mail addresses. A rule may either explicitly <q>allow</q> access or <q>deny</q> access based on the rule's <em>Access type</em>, <em>Rule type</em>, and <em>Mask</em>. For <em>Username</em> and <em>E-Mail</em> rule types, if the username or e-mail address of an existing account or new registration matches the <em>Mask</em> of a <q>deny</q> rule, but not an <q>allow</q> rule, then the account will not be created (for new registrations) or able to log in (for existing accounts).
      The user restrictions module could also be used to prevent new users from registering with usernames like <q>Admin</q> or with e-mail addresses from certain domains. Existing logged-in users with e-mail addresses or usernames that match a <q>deny</q> rule (but not an <q>allow</q> rule) are not immediately logged out (but once they log out, may not log back in), Be careful to not create a <q>deny</q> rule that includes your administrative account.
      Visitors attempting to view your site from an IP address or hostname that matches a <q>deny</q> rule will receive a <q>banned address</q> message. Drupal checks incoming addresses for potential bans before any other Drupal modules or themes are loaded."
    ) . '</p>';
  }
}

/**
 * Implements hook_permission().
 */
function user_restrictions_permission() {
  $perms = array(
    'edit user restriction rules' => array(
      'title' => t('Edit user restriction rules'),
      'restrict access' => TRUE,
    ),
    'bypass user restriction rules' => array(
      'title' => t('Bypass user restriction rules'),
      'restrict access' => TRUE,
    ),
  );

  return $perms;
}

/**
 * Implements hook_user_restrictions_alter().
 */
function user_restrictions_user_restrictions_alter(&$denied, &$error, $context) {
  if ($context['type'] == 'mail' && $denied) {
    $error['field'] = 'mail';
    $error['message'] = t('The email address %email is reserved, and cannot be used.', array('%email' => $mask));
  }

  if ($context['type'] == 'name' && $denied) {
    $error['field'] = 'name';
    $error['message'] = t('The name %name is a reserved username, and cannot be used.', array('%username' => $mask));
  }
}

/**
 * Implements hook_user_restrictions_info().
 */
function user_restrictions_user_restrictions_info($id, $arg1 = NULL, $arg2 = NULL) {
  switch ($id) {
    case 'fields':
      switch ($arg2) {
        case 'check_mail':
          return array('mail' => $arg1['values']['value']);

        case 'check_name':
          return array('name' => $arg1['values']['value']);

        case 'login':
          $account = user_load($arg1['uid']);
          return array('name' => $account->name);

        case 'profile':
        case 'register':
          return array(
            'mail' => $arg1['values']['mail'],
            'name' => $arg1['values']['name'],
          );
      }
      break;

    case 'status options':
      return array(
        t('Allowed'),
        t('Denied'),
      );

    case 'type options':
      return array(
        'mail' => t('Email'),
        'name' => t('Username'),
      );
  }
}

/**
 * Form validation handler for user_login(), and user_login_block().
 *
 * @see user_login()
 * @see user_login_block()
 */
function user_restrictions_login_form_validate($form, &$form_state) {
  if (!empty($form_state['uid']) && isset($form_state['values']['name'])) {
    $account = user_load($form_state['uid']);
    if (!empty($account)) {
      if (user_access('bypass user restriction rules', $account)) {
        return;
      }

      $error = UserRestrictions::check($form_state, 'login');
      if ($error) {
        form_set_error($error['field'], $error['message']);
      }
    }
  }
}

/**
 * Form validation handler for user_profile_form().
 *
 * @see user_profile_form()
 */
function user_restrictions_user_profile_form_validate($form, &$form_state) {
  $account = $form_state['user'];
  if (user_access('bypass user restriction rules', $account)) {
    return;
  }

  $error = UserRestrictions::check($form_state, 'profile');
  if ($error) {
    form_set_error($error['field'], $error['message']);
  }
}

/**
 * Form validation handler for user_register_form().
 *
 * @see user_register_form()
 */
function user_restrictions_user_register_form_validate($form, &$form_state) {
  $error = UserRestrictions::check($form_state, 'register');
  if ($error) {
    form_set_error($error['field'], $error['message']);
  }
}

/**
 * Loads the restriction rule from the database.
 *
 * @param $urid
 *   The ID of the restriction rule.
 */
function user_restrictions_load($urid) {
  return UserRestrictions::getInstance($urid);
}
